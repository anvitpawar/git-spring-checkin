Awesome — here’s Step 1: updated version of parseProfileString that handles environment block grouping and tagging each line.

⸻

✅ parseProfileString — Handles:
	•	Plaintext detection (for if, elif, else, fi, etc.)
	•	Recognizes environment groups (dev, sit, uat, else)
	•	Tags key-value lines with envGroup to sync later

⸻



function parseProfileString(profileString) {
  const lines = profileString.split('\n');
  const result = [];
  let currentEnvGroup = null;

  lines.forEach((line) => {
    const trimmed = line.trim();

    // Detect plain text lines like if, elif, else, fi, etc.
    const isPlainText =
      /^(if|elif|else|fi)/.test(trimmed) || trimmed.startsWith('echo') || trimmed === '';

    // Detect start of environment block
    if (/if\s*\[\s*\$env\s*==?\s*["']?dev["']?\s*\]/.test(trimmed)) {
      currentEnvGroup = 'dev';
    } else if (/if\s*\[\s*\$env\s*==?\s*["']?sit["']?\s*\]/.test(trimmed)) {
      currentEnvGroup = 'sit';
    } else if (/if\s*\[\s*\$env\s*==?\s*["']?uat["']?\s*\]/.test(trimmed)) {
      currentEnvGroup = 'uat';
    } else if (/else/.test(trimmed)) {
      currentEnvGroup = 'else';
    } else if (/fi/.test(trimmed)) {
      currentEnvGroup = null;
    }

    // Handle key-value pairs (only export lines)
    if (trimmed.startsWith('export') && !isPlainText) {
      const lineWithoutExport = trimmed.replace(/^export\s+/, '');
      let key, value, delimiter;

      if (lineWithoutExport.includes('=')) {
        [key, value] = lineWithoutExport.split('=');
        delimiter = 'equal';
      } else if (lineWithoutExport.includes(':')) {
        [key, value] = lineWithoutExport.split(':');
        delimiter = 'colon';
      }

      if (key && value !== undefined) {
        result.push({
          key: key.trim(),
          value: value.trim(),
          delimiter,
          isPlainText: false,
          envGroup: currentEnvGroup,
          isAPP: key.trim().startsWith('APP_'),
        });
      } else {
        // Handle malformed or empty key-value lines as plain text
        result.push({
          text: trimmed,
          isPlainText: true,
        });
      }
    } else {
      // Handle all non-key-value lines
      result.push({
        text: trimmed,
        isPlainText: true,
        envGroup: currentEnvGroup,
      });
    }
  });

  return result;
}



⸻

Next: I’ll send the updated profileArrayToString that respects the env grouping and plain text. Shall I continue?


Great — here’s Step 2: updated profileArrayToString that safely converts the structured array back to the profile string, respecting your delimiter logic and formatting.

⸻

✅ profileArrayToString — Handles:
	•	Conversion from array back to profile string
	•	Supports = or : delimiter
	•	Skips empty keys
	•	Preserves isPlainText lines as-is

⸻



function profileArrayToString(pairs) {
  return pairs
    .map((item) => {
      if (item.isPlainText) return item.text;

      const { key, value, delimiter } = item;

      if (!key && !value) return '';
      if (key && !value) return key;

      if (delimiter === 'equal') {
        return `export ${key}=${value}`;
      } else if (delimiter === 'colon') {
        return `export ${key}:${value}`;
      }

      return `export ${key}=${value}`; // default fallback
    })
    .join('\n');
}



⸻

This will ensure:
	•	APP_ and other exports are formatted properly
	•	Environment group values show up cleanly
	•	No extra lines or malformed exports

⸻

Next up: the core UI logic inside KeyValuePair.jsx — with add/remove buttons specific to environment blocks. Ready?


Perfect — here’s Step 3: the updated KeyValuePair.jsx component.

This version:
	•	Detects and groups by envGroup
	•	Shows one “Add Pair” button per environment group
	•	Syncs added keys across all group members
	•	Disables “Add Pair” for non-APP or non-env keys
	•	Handles editable-only or read-only fields correctly

⸻

✅ KeyValuePair.jsx

import React from 'react';

const KeyValuePair = ({
  pairs,
  onChange,
  onAddPair,
  onRemovePair,
}) => {
  const handleKeyChange = (index, newKey) => {
    const updated = [...pairs];
    updated[index].key = newKey;
    onChange(updated, updated[index].envGroup);
  };

  const handleValueChange = (index, newValue) => {
    const updated = [...pairs];
    updated[index].value = newValue;
    onChange(updated, updated[index].envGroup);
  };

  const isAddable = (item) =>
    (item.key?.startsWith('APP_') || item.envGroup) && !item.isPlainText;

  const grouped = {};
  pairs.forEach((item, index) => {
    const groupKey = item.envGroup || `single-${index}`;
    if (!grouped[groupKey]) grouped[groupKey] = [];
    grouped[groupKey].push({ ...item, index });
  });

  return (
    <div>
      {Object.entries(grouped).map(([groupKey, groupItems]) => (
        <div key={groupKey} style={{ marginBottom: '1rem' }}>
          {groupItems.map((item, i) =>
            item.isPlainText ? (
              <pre key={i} style={{ background: '#f5f5f5' }}>{item.text}</pre>
            ) : (
              <div key={i} style={{ display: 'flex', gap: '10px', marginBottom: '5px' }}>
                <input
                  type="text"
                  value={item.key}
                  onChange={(e) => handleKeyChange(item.index, e.target.value)}
                  placeholder="Key"
                  disabled={item.isPlainText}
                  style={{ flex: 1 }}
                />
                <span>{item.delimiter === 'colon' ? ':' : '='}</span>
                <input
                  type="text"
                  value={item.value}
                  onChange={(e) => handleValueChange(item.index, e.target.value)}
                  placeholder="Value"
                  disabled={item.isPlainText}
                  style={{ flex: 1 }}
                />
                <button
                  onClick={() => onRemovePair(item.index, item.envGroup)}
                  style={{ background: 'red', color: 'white' }}
                >
                  Remove
                </button>
              </div>
            )
          )}
          {/* Add Pair button only once per group and only if allowed */}
          {isAddable(groupItems[0]) && (
            <button
              onClick={() => onAddPair(groupItems[0].envGroup)}
              style={{ background: 'green', color: 'white', marginTop: '5px' }}
            >
              Add Pair
            </button>
          )}
        </div>
      ))}
    </div>
  );
};

export default KeyValuePair;



⸻

Next, I’ll share how your ProfileEditor.jsx should handle the onAddPair and onRemovePair logic to update all items in a group. Want that part now?
