function parseProfileString(str) {
  return lines.map((line) => {
    line = line.trim();
    let key = '', value = '', delimiter = '';

    // Check for shell/control keywords and mark as plain text immediately
    const shellKeywordPattern = /^(export|if|fi|elif|else|then|do|done|while|for|echo)\b/;
    const exitPattern = /^.*exit\s+\d+/;

    let isPlainText = false;

    if (shellKeywordPattern.test(line) || exitPattern.test(line)) {
      isPlainText = true;
      return { key: line, value: '', delimiter: 'none', isPlainText };
    }

    const colonIndex = line.indexOf(':');
    const equalIndex = line.indexOf('=');

    if (colonIndex !== -1) {
      key = line.slice(0, colonIndex).trim();
      value = line.slice(colonIndex + 1).trim();
      delimiter = 'colon';
    } else if (equalIndex !== -1) {
      key = line.slice(0, equalIndex).trim();
      value = line.slice(equalIndex + 1).trim();
      delimiter = 'equal';
    } else {
      key = line;
      delimiter = 'none';
    }

    // Strip trailing "\" if present
    if (key.startsWith('')) key = key.slice(1, -1);
    if (value.endsWith(',\\')) value = value.slice(0, -2).trim();

    // Extra conditions for math/test/command substitution handling
    if (
      delimiter === 'none' ||
      /[`$()]/.test(value) ||
      /^\s*\$*begin:math:display.*\$*end:math:display/.test(line) ||
      /^\s*exit\s+\d+/.test(line.trim())
    ) {
      isPlainText = true;
    }

    return { key, value, delimiter, isPlainText };
  });
}